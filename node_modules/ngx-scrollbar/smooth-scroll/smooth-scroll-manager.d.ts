import { _Left, _Top } from '@angular/cdk/scrolling';
import { SmoothScrollElement, SmoothScrollOptions, SmoothScrollToOptions } from './smooth-scroll.model';
import * as ɵngcc0 from '@angular/core';
export declare class SmoothScrollManager {
    private _document;
    private _platform;
    private readonly _defaultOptions;
    private _onGoingScrolls;
    private get _w();
    /**
     * Timing method
     */
    private get _now();
    constructor(_document: any, _platform: object, customDefaultOptions: SmoothScrollToOptions);
    /**
     * changes scroll position inside an element
     */
    private _scrollElement;
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    private _getElement;
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    private _initSmoothScroll;
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    private _isFinished;
    /**
     * Terminates an ongoing smooth scroll
     */
    private _interrupted;
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    private _destroy;
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    private _step;
    private _applyScrollToOptions;
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable: SmoothScrollElement, customOptions: SmoothScrollToOptions): Promise<void>;
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable: SmoothScrollElement, target: SmoothScrollElement, customOptions: SmoothScrollOptions & _Top & _Left): Promise<void>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SmoothScrollManager, [null, null, { optional: true; }]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmQudHMiLCJzb3VyY2VzIjpbInNtb290aC1zY3JvbGwtbWFuYWdlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX0xlZnQsIF9Ub3AgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcbmltcG9ydCB7IFNtb290aFNjcm9sbEVsZW1lbnQsIFNtb290aFNjcm9sbE9wdGlvbnMsIFNtb290aFNjcm9sbFRvT3B0aW9ucyB9IGZyb20gJy4vc21vb3RoLXNjcm9sbC5tb2RlbCc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBTbW9vdGhTY3JvbGxNYW5hZ2VyIHtcbiAgICBwcml2YXRlIF9kb2N1bWVudDtcbiAgICBwcml2YXRlIF9wbGF0Zm9ybTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9kZWZhdWx0T3B0aW9ucztcbiAgICBwcml2YXRlIF9vbkdvaW5nU2Nyb2xscztcbiAgICBwcml2YXRlIGdldCBfdygpO1xuICAgIC8qKlxuICAgICAqIFRpbWluZyBtZXRob2RcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldCBfbm93KCk7XG4gICAgY29uc3RydWN0b3IoX2RvY3VtZW50OiBhbnksIF9wbGF0Zm9ybTogb2JqZWN0LCBjdXN0b21EZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIGdpdmVuIHBhcmFtZXRlciBvZiB0eXBlIEhUTUxFbGVtZW50LCBFbGVtZW50UmVmIG9yIHNlbGVjdG9yXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0RWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIGRlc3Ryb3llciBzdHJlYW0sIHJlLWluaXRpYWxpemVzIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIF9pbml0U21vb3RoU2Nyb2xsO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzbW9vdGggc2Nyb2xsIGhhcyByZWFjaGVkLCBjbGVhbnMgdXAgdGhlIHNtb290aCBzY3JvbGwgc3RyZWFtIGFuZCByZXNvbHZlcyBpdHMgcHJvbWlzZVxuICAgICAqL1xuICAgIHByaXZhdGUgX2lzRmluaXNoZWQ7XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhbiBvbmdvaW5nIHNtb290aCBzY3JvbGxcbiAgICAgKi9cbiAgICBwcml2YXRlIF9pbnRlcnJ1cHRlZDtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBkZXN0cm95ZXIgZnVuY3Rpb24sIHJ1bnMgaWYgdGhlIHNtb290aCBzY3JvbGwgaGFzIGZpbmlzaGVkIG9yIGludGVycnVwdGVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZGVzdHJveTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIGNhbGxlZCByZWN1cnNpdmVseSB0aGF0LCBnaXZlbiBhIGNvbnRleHQsIHN0ZXBzIHRocm91Z2ggc2Nyb2xsaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3RlcDtcbiAgICBwcml2YXRlIF9hcHBseVNjcm9sbFRvT3B0aW9ucztcbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy4gVGhpcyBpcyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzY3JvbGxUb1xuICAgICAqIG1ldGhvZCwgc2luY2UgYnJvd3NlcnMgYXJlIG5vdCBjb25zaXN0ZW50IGFib3V0IHdoYXQgc2Nyb2xsTGVmdCBtZWFucyBpbiBSVEwuIEZvciB0aGlzIG1ldGhvZFxuICAgICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcbiAgICAgKiBvZiB0aGUgbGF5b3V0IGRpcmVjdGlvbi4gc3RhcnQgYW5kIGVuZCByZWZlciB0byBsZWZ0IGFuZCByaWdodCBpbiBhbiBMVFIgY29udGV4dCBhbmQgdmljZS12ZXJzYVxuICAgICAqIGluIGFuIFJUTCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSBzY3JvbGxhYmxlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gY3VzdG9tT3B0aW9ucyBzcGVjaWZpZWQgdGhlIG9mZnNldHMgdG8gc2Nyb2xsIHRvLlxuICAgICAqL1xuICAgIHNjcm9sbFRvKHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIGVsZW1lbnQgYnkgcmVmZXJlbmNlIG9yIHNlbGVjdG9yXG4gICAgICovXG4gICAgc2Nyb2xsVG9FbGVtZW50KHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIHRhcmdldDogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsT3B0aW9ucyAmIF9Ub3AgJiBfTGVmdCk6IFByb21pc2U8dm9pZD47XG59XG4iXX0=