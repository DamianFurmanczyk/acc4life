import { __decorate, __metadata, __param } from 'tslib';
import { Input, Optional, NgZone, Output, Directive, NgModule } from '@angular/core';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { NgScrollbar, NgScrollbarModule } from 'ngx-scrollbar';
import { Subject, Subscription, Observable } from 'rxjs';
import { tap, map, distinctUntilChanged, filter } from 'rxjs/operators';

// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngx-scrollbar';
import * as ɵngcc2 from '@angular/cdk/bidi';
class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if it scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
}
ScrollReached.ɵfac = function ScrollReached_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ScrollReached.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ScrollReached, inputs: { offset: ["reachedOffset", "offset"] } });
__decorate([
    Input('reachedOffset'),
    __metadata("design:type", Object)
], ScrollReached.prototype, "offset", void 0);
let VerticalScrollReached = class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
};
VerticalScrollReached.ɵfac = function VerticalScrollReached_Factory(t) { return new (t || VerticalScrollReached)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgScrollbar, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
VerticalScrollReached.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VerticalScrollReached, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
VerticalScrollReached = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], VerticalScrollReached);
let HorizontalScrollReached = class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
};
HorizontalScrollReached.ɵfac = function HorizontalScrollReached_Factory(t) { return new (t || HorizontalScrollReached)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgScrollbar, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
HorizontalScrollReached.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HorizontalScrollReached, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
HorizontalScrollReached = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], HorizontalScrollReached);
let NgScrollbarReachedTop = class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
};
NgScrollbarReachedTop.ɵfac = function NgScrollbarReachedTop_Factory(t) { return new (t || NgScrollbarReachedTop)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgScrollbar, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NgScrollbarReachedTop.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgScrollbarReachedTop, selectors: [["", "reachedTop", ""], ["", "reached-top", ""]], outputs: { reachedTop: "reachedTop" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NgScrollbarReachedTop.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedTop.prototype, "reachedTop", void 0);
NgScrollbarReachedTop = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], NgScrollbarReachedTop);
let NgScrollbarReachedBottom = class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
};
NgScrollbarReachedBottom.ɵfac = function NgScrollbarReachedBottom_Factory(t) { return new (t || NgScrollbarReachedBottom)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgScrollbar, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NgScrollbarReachedBottom.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgScrollbarReachedBottom, selectors: [["", "reachedBottom", ""], ["", "reached-bottom", ""]], outputs: { reachedBottom: "reachedBottom" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NgScrollbarReachedBottom.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedBottom.prototype, "reachedBottom", void 0);
NgScrollbarReachedBottom = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], NgScrollbarReachedBottom);
let NgScrollbarReachedStart = class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
};
NgScrollbarReachedStart.ɵfac = function NgScrollbarReachedStart_Factory(t) { return new (t || NgScrollbarReachedStart)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgScrollbar, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality)); };
NgScrollbarReachedStart.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgScrollbarReachedStart, selectors: [["", "reachedStart", ""], ["", "reached-start", ""]], outputs: { reachedStart: "reachedStart" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NgScrollbarReachedStart.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedStart.prototype, "reachedStart", void 0);
NgScrollbarReachedStart = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
], NgScrollbarReachedStart);
let NgScrollbarReachedEnd = class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
};
NgScrollbarReachedEnd.ɵfac = function NgScrollbarReachedEnd_Factory(t) { return new (t || NgScrollbarReachedEnd)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgScrollbar, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality)); };
NgScrollbarReachedEnd.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgScrollbarReachedEnd, selectors: [["", "reachedEnd", ""], ["", "reached-end", ""]], outputs: { reachedEnd: "reachedEnd" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NgScrollbarReachedEnd.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedEnd.prototype, "reachedEnd", void 0);
NgScrollbarReachedEnd = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
], NgScrollbarReachedEnd);

let NgScrollbarReachedModule = class NgScrollbarReachedModule {
};
NgScrollbarReachedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgScrollbarReachedModule });
NgScrollbarReachedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgScrollbarReachedModule_Factory(t) { return new (t || NgScrollbarReachedModule)(); }, imports: [[
            NgScrollbarModule,
            BidiModule
        ]] });



/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgScrollbarReachedTop, [{
        type: Directive,
        args: [{
                selector: '[reachedTop], [reached-top]'
            }]
    }], function () { return [{ type: ɵngcc1.NgScrollbar, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { reachedTop: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgScrollbarReachedBottom, [{
        type: Directive,
        args: [{
                selector: '[reachedBottom], [reached-bottom]'
            }]
    }], function () { return [{ type: ɵngcc1.NgScrollbar, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { reachedBottom: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgScrollbarReachedStart, [{
        type: Directive,
        args: [{
                selector: '[reachedStart], [reached-start]'
            }]
    }], function () { return [{ type: ɵngcc1.NgScrollbar, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.Directionality }]; }, { reachedStart: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgScrollbarReachedEnd, [{
        type: Directive,
        args: [{
                selector: '[reachedEnd], [reached-end]'
            }]
    }], function () { return [{ type: ɵngcc1.NgScrollbar, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.Directionality }]; }, { reachedEnd: [{
            type: Output
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgScrollbarReachedModule, { declarations: function () { return [NgScrollbarReachedTop,
        NgScrollbarReachedBottom,
        NgScrollbarReachedStart,
        NgScrollbarReachedEnd]; }, imports: function () { return [NgScrollbarModule,
        BidiModule]; }, exports: function () { return [NgScrollbarReachedTop,
        NgScrollbarReachedBottom,
        NgScrollbarReachedStart,
        NgScrollbarReachedEnd]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgScrollbarReachedModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NgScrollbarModule,
                    BidiModule
                ],
                declarations: [
                    NgScrollbarReachedTop,
                    NgScrollbarReachedBottom,
                    NgScrollbarReachedStart,
                    NgScrollbarReachedEnd
                ],
                exports: [
                    NgScrollbarReachedTop,
                    NgScrollbarReachedBottom,
                    NgScrollbarReachedStart,
                    NgScrollbarReachedEnd
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NgScrollbarReachedBottom, NgScrollbarReachedEnd, NgScrollbarReachedModule, NgScrollbarReachedStart, NgScrollbarReachedTop };

//# sourceMappingURL=ngx-scrollbar-reached-event.js.map