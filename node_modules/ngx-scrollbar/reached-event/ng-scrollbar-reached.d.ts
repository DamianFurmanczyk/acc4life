import { OnInit, OnDestroy, NgZone } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { Observable, Subject, Subscription } from 'rxjs';
import { NgScrollbar } from 'ngx-scrollbar';
import * as ɵngcc0 from '@angular/core';
declare abstract class ScrollReached implements OnDestroy {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    /** offset: Reached offset value in px */
    offset: number;
    /**
     * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
     *
     * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
     */
    protected scrollEvent: Subject<any>;
    /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
    protected subscription: Subscription;
    /** A stream used to assign the reached output */
    protected reachedEvent: Observable<any>;
    protected constructor(scrollbar: NgScrollbar, zone: NgZone);
    ngOnDestroy(): void;
    protected scrollReached(): Observable<any>;
    protected abstract reached(offset: number, e?: any): boolean;
}
declare abstract class VerticalScrollReached extends ScrollReached implements OnInit {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    protected constructor(scrollbar: NgScrollbar, zone: NgZone);
    ngOnInit(): void;
}
declare abstract class HorizontalScrollReached extends ScrollReached implements OnInit {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    protected constructor(scrollbar: NgScrollbar, zone: NgZone);
    ngOnInit(): void;
}
export declare class NgScrollbarReachedTop extends VerticalScrollReached implements OnInit {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    /** Stream that emits when scroll has reached the top */
    reachedTop: Observable<any>;
    constructor(scrollbar: NgScrollbar, zone: NgZone);
    ngOnInit(): void;
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    protected reached(offset: number, e: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgScrollbarReachedTop, [{ optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgScrollbarReachedTop, "[reachedTop], [reached-top]", never, {}, { "reachedTop": "reachedTop"; }, never>;
}
export declare class NgScrollbarReachedBottom extends VerticalScrollReached implements OnInit {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    /** Stream that emits when scroll has reached the bottom */
    reachedBottom: Observable<any>;
    constructor(scrollbar: NgScrollbar, zone: NgZone);
    ngOnInit(): void;
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    protected reached(offset: number, e: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgScrollbarReachedBottom, [{ optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgScrollbarReachedBottom, "[reachedBottom], [reached-bottom]", never, {}, { "reachedBottom": "reachedBottom"; }, never>;
}
export declare class NgScrollbarReachedStart extends HorizontalScrollReached implements OnInit {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    private dir;
    /** Stream that emits when scroll has reached the start */
    reachedStart: Observable<any>;
    constructor(scrollbar: NgScrollbar, zone: NgZone, dir: Directionality);
    ngOnInit(): void;
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    protected reached(offset: number, e: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgScrollbarReachedStart, [{ optional: true; }, null, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgScrollbarReachedStart, "[reachedStart], [reached-start]", never, {}, { "reachedStart": "reachedStart"; }, never>;
}
export declare class NgScrollbarReachedEnd extends HorizontalScrollReached implements OnInit {
    protected scrollbar: NgScrollbar;
    protected zone: NgZone;
    private dir;
    /** Stream that emits when scroll has reached the end */
    reachedEnd: Observable<any>;
    constructor(scrollbar: NgScrollbar, zone: NgZone, dir: Directionality);
    ngOnInit(): void;
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    protected reached(offset: number, e: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgScrollbarReachedEnd, [{ optional: true; }, null, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgScrollbarReachedEnd, "[reachedEnd], [reached-end]", never, {}, { "reachedEnd": "reachedEnd"; }, never>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLXJlYWNoZWQuZC50cyIsInNvdXJjZXMiOlsibmctc2Nyb2xsYmFyLXJlYWNoZWQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25Jbml0LCBPbkRlc3Ryb3ksIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nU2Nyb2xsYmFyIH0gZnJvbSAnbmd4LXNjcm9sbGJhcic7XG5kZWNsYXJlIGFic3RyYWN0IGNsYXNzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyO1xuICAgIHByb3RlY3RlZCB6b25lOiBOZ1pvbmU7XG4gICAgLyoqIG9mZnNldDogUmVhY2hlZCBvZmZzZXQgdmFsdWUgaW4gcHggKi9cbiAgICBvZmZzZXQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTdHJlYW0gdGhhdCBlbWl0cyBzY3JvbGwgZXZlbnQgd2hlbiBgTmdTY3JvbGxiYXIuc2Nyb2xsZWRgIGlzIGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICogKipOT1RFOioqIFRoaXMgc3ViamVjdCBpcyB1c2VkIHRvIGhvbGQgdGhlIHBsYWNlIG9mIGBOZ1Njcm9sbGJhci5zY3JvbGxlZGAgd2hlbiBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsRXZlbnQ6IFN1YmplY3Q8YW55PjtcbiAgICAvKiogc3Vic2NyaXB0aW9uOiBTY3JvbGxlZCBldmVudCBzdWJzY3JpcHRpb24sIHVzZWQgdG8gdW5zdWJzY3JpYmUgZnJvbSB0aGUgZXZlbnQgb24gZGVzdHJveSAqL1xuICAgIHByb3RlY3RlZCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICAvKiogQSBzdHJlYW0gdXNlZCB0byBhc3NpZ24gdGhlIHJlYWNoZWQgb3V0cHV0ICovXG4gICAgcHJvdGVjdGVkIHJlYWNoZWRFdmVudDogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCB6b25lOiBOZ1pvbmUpO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHNjcm9sbFJlYWNoZWQoKTogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlPzogYW55KTogYm9vbGVhbjtcbn1cbmRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgVmVydGljYWxTY3JvbGxSZWFjaGVkIGV4dGVuZHMgU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXI7XG4gICAgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZTtcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3Ioc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgem9uZTogTmdab25lKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xufVxuZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyO1xuICAgIHByb3RlY3RlZCB6b25lOiBOZ1pvbmU7XG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHpvbmU6IE5nWm9uZSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nU2Nyb2xsYmFyUmVhY2hlZFRvcCBleHRlbmRzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXI7XG4gICAgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZTtcbiAgICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAqL1xuICAgIHJlYWNoZWRUb3A6IE9ic2VydmFibGU8YW55PjtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCB6b25lOiBOZ1pvbmUpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSB0b3AgKHZlcnRpY2FsbHkpXG4gICAgICogQHBhcmFtIG9mZnNldCBTY3JvbGwgb2Zmc2V0XG4gICAgICogQHBhcmFtIGUgU2Nyb2xsIGV2ZW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlYWNoZWQob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW47XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRCb3R0b20gZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyO1xuICAgIHByb3RlY3RlZCB6b25lOiBOZ1pvbmU7XG4gICAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBib3R0b20gKi9cbiAgICByZWFjaGVkQm90dG9tOiBPYnNlcnZhYmxlPGFueT47XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgem9uZTogTmdab25lKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgYm90dG9tICh2ZXJ0aWNhbGx5KVxuICAgICAqIEBwYXJhbSBvZmZzZXQgU2Nyb2xsIG9mZnNldFxuICAgICAqIEBwYXJhbSBlIFNjcm9sbCBldmVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkU3RhcnQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXI7XG4gICAgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZTtcbiAgICBwcml2YXRlIGRpcjtcbiAgICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHN0YXJ0ICovXG4gICAgcmVhY2hlZFN0YXJ0OiBPYnNlcnZhYmxlPGFueT47XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgem9uZTogTmdab25lLCBkaXI6IERpcmVjdGlvbmFsaXR5KTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKGhvcml6b250YWxseSlcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcbiAgICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nU2Nyb2xsYmFyUmVhY2hlZEVuZCBleHRlbmRzIEhvcml6b250YWxTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhcjtcbiAgICBwcm90ZWN0ZWQgem9uZTogTmdab25lO1xuICAgIHByaXZhdGUgZGlyO1xuICAgIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgZW5kICovXG4gICAgcmVhY2hlZEVuZDogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIGNvbnN0cnVjdG9yKHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHpvbmU6IE5nWm9uZSwgZGlyOiBEaXJlY3Rpb25hbGl0eSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGVuZCAoaG9yaXpvbnRhbGx5KVxuICAgICAqIEBwYXJhbSBvZmZzZXQgU2Nyb2xsIG9mZnNldFxuICAgICAqIEBwYXJhbSBlIFNjcm9sbCBldmVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuO1xufVxuZXhwb3J0IHt9O1xuIl19